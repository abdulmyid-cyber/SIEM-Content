title: Unauthenticated Cisco ASA/FTD WebVPN Access Attempts (CVE-2025-20333 / CVE-2025-20362) - Low Noise
id: 
status: experimental
description: |
  Detects likely unauthenticated access attempts to Cisco ASA/FTD WebVPN endpoints by correlating
  successful HTTP responses (200) that set a WebVPN cookie or return portal assets with the
  absence of a corresponding VPN authentication success for the same source IP in a short time window.
  This rule is tuned to reduce false positives from legitimate authenticated admin/jump-host activity.
author: Abdul Rahman (abdulmyid@gmail.com)
date: 2025-09-26
references:
  - https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-webvpn-z5xP8EUB
  - https://www.cisa.gov/news-events/directives/ed-25-03-identify-and-mitigate-potential-compromise-cisco-devices
tags: [attack.exploitation, cisco, vpn, webvpn, asa, ftd, cve-2025-20333, cve-2025-20362, tactic:initial-access]

# Use two log sources: network/http (web requests) and authentication (vpn/auth logs).
# Map fields from your environment (examples: http.request.uri, http.request.body, http.response.headers, auth.result).
logsource:
  - product: network
    service: http
  - product: firewall
    service: authentication
detection:
  selection_http:
    # HTTP events hitting WebVPN endpoints and returning success (portal asset or Set-Cookie: webvpn)
    http.request.uri|contains:
      - "+CSCOE+"
      - "/webvpn"
      - "/vpn"
      - "/CSCOSSLC/"
    http.response.status|in: [200, "200"]
    # Many logs show Set-Cookie header as 'Set-Cookie: webvpn' or cookie key 'webvpn'
    http.response.headers|contains: "Set-Cookie: webvpn" 
    # long query string to portal.css is a strong indicator; optional
    # uri|regex: '\/\+CSCOE\+\/portal\.css\?.{50,}' 
  selection_auth_success:
    # Authentication success events from VPN/AAA logs. Map field names as appropriate.
    event.type: "vpn_auth" OR "authentication"
    auth.result|in: ["success", "SUCCESS", "Accepted"]
    destination.ip: null  # placeholder; real mapping should match the firewall device IP field used in auth logs
  # Correlation condition:
  # - An HTTP portal response (selection_http) from a source IP that did NOT have an auth success within the prior 5 minutes.
  # Implementation note: many SIEMs implement this by using a join/lookup or subsearch. Here we express intent for Sigma.
  condition: selection_http and not selection_auth_success
  # To reduce alert noise further, require the http.request to include one of the suspicious patterns (long portal queries or base64-like POSTs)
  detection_options:
    require_additional_indicator: true
    additional_indicators:
      - http.request.uri|regex: '\/\+CSCOE\+\/portal\.css\?.{50,}'
      - http.request.body|regex: '(?:[A-Za-z0-9+/]{30,}={0,2})'
falsepositives:
  - Legitimate monitoring or healthcheck systems that fetch portal assets without authenticating (add those IPs to the trusted list).
  - One-off support activity where admin uses web portal and auth logs are not correlated correctly (ensure auth log ingestion).
level: high
fields:
  - timestamp
  - source.ip
  - destination.ip
  - http_method
  - http.request.uri
  - http.request.body
  - http.user_agent
  - http.response.status
  - http.response.headers
  - auth.result
  - auth.username
tags:
  - ATT&CK:T1190
  - ATT&CK:T1210
# Variables to populate in your environment
# - $trusted_ip_list : management/jump-hosts, monitoring systems, known scanners
# - $auth_log_index  : VPN/AAA auth events index or source
# Tuning & deployment notes
# 1) Populate $trusted_ip_list and filter them before alerting (trusted management/monitoring).
# 2) Ensure your SIEM ingests VPN/AAA success logs - without them this rule loses correlation power.
# 3) Implement as a correlation rule:
#    - Step A: search HTTP logs for selection_http in the last 5 minutes.
#    - Step B: search auth logs for auth successes from same source.ip in the last 5 minutes.
#    - Step C: Alert when Step A returns results and Step B returns none.
# 4) Add thresholding to reduce noisy single-request alerts (e.g., alert if same source.ip triggers selection_http >= 2 times in 5 minutes).
# 5) If your environment can't correlate, fall back to a stricter single-log rule: require selection_http **and** additional_indicators (long portal query OR base64 body).
# Example ELK-style correlation pseudo (conceptual)
#
# 1) Find HTTP events of interest (last 5m):
#    http_hits = search(index=network-http, uri:(*+CSCOE+* OR *webvpn* OR *CSCOSSLC*), response.status:200, response.headers:*webvpn*)
#
# 2) For each http_hit.source.ip, check auth index for success in last 5m:
#    auth_ok = search(index=vpn-auth, source.ip:http_hit.source.ip, auth.result:success, @timestamp:[now-5m TO now])
#
# 3) If auth_ok is empty -> create alert / case (collect request body, headers, full packet capture if available).
# Recommended immediate play on alert
# 1) Enrich source.ip (whois, passive DNS, geolocation).
# 2) Check VPN auth logs for any attempted or successful logins from same IP outside the 5m window.
# 3) Pull full request body, headers and any related PCAPs; snapshot firewall config; increase logging.
# 4) If multiple indicators present (base64 payloads, long portal.css queries, repeated hits), treat as high-confidence and follow IR steps (isolate, preserve logs, patch if not patched).
